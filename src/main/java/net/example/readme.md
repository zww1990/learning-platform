# java提供两种方式创建线程
 1. 继承Thread类，并且覆盖run()方法。
 1. 创建实现Runnable接口的类，使用带参数的Thread构造器创建Thread对象。

# 使用工厂类创建线程
 * 更容易修改类，或者改变创建对象的方式。
 * 更容易为有限资源限制创建对象的数目。
 * 更容易为创建的对象生成统计数据。

# java有两种异常
 1. 非运行时异常：必须在方法声明的throws语句中指定，或者在方法体内捕获。
 1. 运行时异常：不必在方法声明中指定，也不需要在方法体内捕获。

注：当线程抛出一个未捕获到的异常时，JVM首先查找线程对象的未捕获异常处理器，如果找不到，JVM继续查找线程对象所在的线程组的未捕获异常处理器，如果还是找不到，JVM将继续查找默认的未捕获异常处理器，如果没有一个处理器存在，JVM则将堆栈异常记录打印到控制台，并退出程序。

注：在多线程中，如果对象的属性不需要被所有线程共享，需要使用线程局部变量ThreadLocal。对于一些执行同样任务的线程，可以把这些线程放进一个线程组ThreadGroup里，只需要一个单一的调用，就可以对组内线程对象进行访问并操作它们。

# java提供两种基本同步机制
 1. 使用synchronized实现同步方法
 1. 使用基于Lock接口实现同步

# java提供更高级的同步机制来实现多线程间的同步
 1. Semaphore：是一种计数器，用来保护一个或者多个共享资源的访问。
 1. CountDownLatch：在完成一组正在其他线程中执行的操作之前，它允许线程一直等待。
 1. CyclicBarrier：它允许多个线程在某个集合点处进行相互等待。
 1. Phaser：它把并发任务分成多个阶段运行，在开始下一个阶段之前，当前阶段中的所有线程都必须执行完成。
 1. Exchanger：它提供了两个线程之间的数据交换点。
