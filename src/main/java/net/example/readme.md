# java提供两种方式创建线程
 1. 继承Thread类，并且覆盖run()方法。
 1. 创建实现Runnable接口的类，使用带参数的Thread构造器创建Thread对象。

# 使用工厂类创建线程
 * 更容易修改类，或者改变创建对象的方式。
 * 更容易为有限资源限制创建对象的数目。
 * 更容易为创建的对象生成统计数据。

# java有两种异常
 1. 非运行时异常：必须在方法声明的throws语句中指定，或者在方法体内捕获。
 1. 运行时异常：不必在方法声明中指定，也不需要在方法体内捕获。

注：当线程抛出一个未捕获到的异常时，JVM首先查找线程对象的未捕获异常处理器，如果找不到，JVM继续查找线程对象所在的线程组的未捕获异常处理器，如果还是找不到，JVM将继续查找默认的未捕获异常处理器，如果没有一个处理器存在，JVM则将堆栈异常记录打印到控制台，并退出程序。

注：在多线程中，如果对象的属性不需要被所有线程共享，需要使用线程局部变量ThreadLocal。对于一些执行同样任务的线程，可以把这些线程放进一个线程组ThreadGroup里，只需要一个单一的调用，就可以对组内线程对象进行访问并操作它们。

# java提供两种基本同步机制
 1. 使用synchronized实现同步方法
 1. 使用基于Lock接口实现同步

# java提供更高级的同步机制来实现多线程间的同步
 1. Semaphore：是一种计数器，用来保护一个或者多个共享资源的访问。
 1. CountDownLatch：在完成一组正在其他线程中执行的操作之前，它允许线程一直等待。
 1. CyclicBarrier：它允许多个线程在某个集合点处进行相互等待。
 1. Phaser：它把并发任务分成多个阶段运行，在开始下一个阶段之前，当前阶段中的所有线程都必须执行完成。
 1. Exchanger：它提供了两个线程之间的数据交换点。

# 线程执行器Executor
注：分离了任务的创建和执行，仅需要实现Runnable接口的对象，然后将这些对象发送给执行器，执行器通过创建所需的线程，来负责这些Runnable对象的创建、实例化以及运行，它使用了线程池来提高应用程序的性能，当发送一个任务给执行器时，执行器会尝试使用线程池中的线程来执行这个任务，避免了不断地创建和销毁线程而导致系统性能下降。

# 执行器提供了两方面的增强
 1. Callable接口的主方法名称为call()，可以返回结果。
 1. 当发送一个Callable对象给执行器时，将获得一个实现了Future接口的对象，可以使用这个对象来控制Callable对象的状态和结果。

# Fork/Join(分解/合并)框架
注：用来解决能够通过分治技术将问题拆分成小任务的问题。在一个任务中，先检查将要解决的问题的大小，如果大于一个设定的大小，那就将问题拆分成可以通过框架来执行的小任务。如果问题的大小比设定的大小要小，就可以直接在任务里解决这个问题，然后，根据需要返回任务的结果。

# Fork/Join框架基于两种操作
 1. 分解（Fork）操作：当需要将一个任务拆分成更小的多个任务时，在框架中执行这些任务。
 1. 合并（Join）操作：当一个主任务等待其创建的多个子任务的完成执行。

# Fork/Join框架执行的任务限制
 * 任务只能使用fork()和join()操作当作同步机制。如果使用其他的同步机制，工作者线程就不能执行其他任务，当然这些任务是在同步操作里时。
 * 任务不能执行I/O操作。
 * 任务不能抛出非运行时异常，必须在代码中处理掉这些异常。

# Fork/Join框架的核心由两个类组成
 1. ForkJoinPool：这个类实现了ExecutorService接口和工作窃取算法。它管理工作者线程，并提供任务的状态信息，以及任务的执行信息。
 1. ForkJoinTask：这个类是一个将在ForkJoinPool中执行的任务的基类。

# 为了实现Fork/Join任务，需要实现两个类其中之一
 1. RecursiveAction：用于任务没有返回结果的场景。
 1. RecursiveTask：用于任务有返回结果的场景。

